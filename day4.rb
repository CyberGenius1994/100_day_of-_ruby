# Classes

=begin
Ім'я класу всього лиш константа, так як всі класи в Ruby  посилаються на об'єкт типу Class.
Клас може містити в собі константи, змінні класу, методи класу, змінні примірника і методи примірника.
Дані рівня класу доступні у всіх об'єктах класу, а дані примірникадоступні тільки одному об'єкту.
=end

class ClassName
  # @!attribute
  # @!method
end

# initialize
=begin
Оскільки дані класу доступні у всьому класі то іїх треба форматувати в момент створення класу.
Метод гарантує виконання в момент виділення памяті для об'єкту.
Метод схожий на конструктор, але він не виконує виділення пам'яті.
Пам'ять виділяється методом new.
=end

# Module
=begin
Містить методи attr, attr_accessor, attr_reader, attr_writer.
attr_accessor - мотод доступу до атрибуту на читання та запис
attr_reader, attr_writer - метод доступу до атрибуту на читання
attr_writer - метод доступу до атрибуту на запис
=end

# self
=begin
Змінна self - посилання на обєкт, від імені якого викликаний метод примірника.
=end

# Методи доступу private, protected, public

class MyClass

  def method1
    #
  end

  def method2
    #
  end

  def method3
    #
  end

  private :method1

  public :method2

  protected :method3

  private

  def mу_method
    #
  end

  def another_method

  end

end

=begin
method1 - закритий
method2 - відкритий
method3 - захищений
mу_method, another_method - закриті оскільки нижче private викликається без параметра.
public - не накладає ніяких обмежень ні на доступ до методу ні на його видимість
private - метод доступний тільки всередині класу і його підкласів і може викликатися тільки в функціональній формі від імені self
protected - метод може викликатися тільки всередині класу але не обовязково від імені self
По замовчуванню всі методи класу public окрім initialize
=end

# Наслідування одного класу від іншого
class OtherClass
  #
end

class MyClass < OtherClass
  #
end

# super
=begin
Якщо новий метод має таке ж ім'я, що й наявний, то старий метод перевизначається.
Якщо новий метод повенен звернутися до заміненого ним "батьківського" методу, то можна скористатися ключовим словом super
=end

# Синоніми методів
alias_method :newname, :oldname

=begin
Число параметрів для синоніму біде таким же як для старого, і виклик методу буде таким же.
При використанні синоніму створюється копія методу, тому якщо в результаті вихідний методі буде змінений то це ніяк не вплине на синонім.
=end

# alias
=begin
Поводить себе майже як alias_method, але дозволяє створювати синоніми не тільки методів а й глобальних змінних, а його аргументи не розділяються комами.
=end