# Синтаксис
=begin
1. Дужки для виклику методів можна опускати.
foobar
foobar()
foobar(a, b, c)
foobar a, b, c

2. Передавати хеш в метод можна лише в круглих дужках
my_method({1: 1, b: 2, 5 => 25}) - правильно
my_method {1: 1, b: 2, 5 => 25} - неправильно, оскільки 1 фігурна дужка визначається як початок блоку

3. Якщо хеш останній або єдиний з параметрів то фігурні дужки можна опустити
my_method(1: 1, b: 2, 5 => 25)

4. Правильне використання пробілів
x = y + z
x = y+z
x = y+ z
x = y +z
Може здатися що всі 4 вирази ідентичні, насправді перші 3 ідентичні, а 4 випадок аналізатор прийме його як метод y з параметром +z.
Аналогічно
x = y*z - множення
x = y *z - виклик методу y з параметром +z

5. В іменах ідентифікаторів знак підкреслення означає малу літеру, тому якщо ім'я ідентифікатора починається з підкреслення, то навіть якщо наступна буква буде великою, вважати такий ідентифікатор константою не можна.

6. В лінійній послідовності вкладених виразів if застосовується ключове слово elsif, а не else if або elif.

7. Ключові слова в рубі не можна назвати по-справжньому зарезервованими.
Якщо метод викликається від імені деякого об'єкту (і в інших випадках коли не виникає однозначності) то метод може співпадати з зарезервованим словом.
Проте робити такі дії треба з обережністю.

8. Ключові слова then і do можна опускати в деяких випадках.

9. ! і ? не є частиною ідентифікаторів, який модифікують. Їх можна розглядати як суфікси.
Оскільки chop і chop! вважаються різними, використовувати ! в іншому місці не дозволяється.
Аналогічно defined?, але defined - ключове слово.

10. Всередині строки символ # ознака початку виразу.
Це означає що в деяких випадках її треба екранувати знаком зворотньої косої лінії, лише тоді, коли після # йде символ {, $ або @

11. В тернарному операторі треба приділяти велику увагу пробілам, оскільки неправильна їх розкладка може привести до помилки
x = my_flag ? 23 : 45 - правильно
x = my_flag? 23 : 45 - синтаксична помилка

12. Ключові слова BEGIN END не мають нічого спільного з begin end

13. при статичній конккатенації рядків пріоритет нижче ніж виклик методу.
  13.1 str = "Перша" 'second'.center(20)
  13.2 str = "Перша" + 'second'.center(20)
  13.3 str = "Перша друга".center(20)
  13.4 str = ("Перша " + 'друга').center(20)
1 і 2 варіант дають одне і те ж, так 3 і 4.

14. В Ruby є декілька псевдозмінних, які виглядають як локальні змінні але застосовуються для спеціальних цілей.
Це self, nil, true, false, __FILE__, __LINE__
=end

